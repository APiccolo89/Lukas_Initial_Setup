function [obj] = find_slab_mode_1(obj,A,Weak_Slab)
% Convert the angle in radians
x     = A.Xpart(:); % x part coordinate
z     = A.Zpart(:); % z part coordinate
y     = A.Ypart(:); % y part coordinate
ang_  = (obj.theta)*pi/180; % angle of the slab
ang_2 = (obj.theta+90)*pi/180; %needed for the linear portion of the slab
r      = [obj.R-obj.D0,obj.R]; % radius upper and lower surface
r_m    = sum(obj.R)./2; % average radius, to compute the linear integral
C      = [obj.Boundary,obj.Boundary-obj.R]; % center of the curvature
sl    = 1    ; 
% select the point that are worth to check if they belong to the slab
ind = (x>=C(1) & x(:)<=C(1)+2.*obj.L0) & z>=-1.5*obj.L0 & z(:)<=1.0;
A_time = cputime;
% Vector version
Layout = x*nan; % Layout the distance array for the slab
Length = Layout; % Lenght the integrated length along the slab
d      = Layout; % a buff containing the distance between the center and the current marker position
arc_angleS = x.*NaN; % array that stores the angular distance 
continent = arc_angleS; % array that identify where is the continental portion
angle_c = continent;
% Compute the angular distance w.r.t. the center C
d(ind==1) = sqrt((x(ind==1)-C(1)).^2+(z(ind==1)- C(2)).^2);
% Compute the angle between the vertical vector stemming from the center of
% circumference and the current marker
arc_angleS(ind==1) = acos((z(ind==1)-C(2))./d(ind==1)).*180/pi;
% find the portion that are considered continent
angle_c(ind==1) = d(ind==1)>=r(2)-obj.Depth_continent+((obj.Depth_continent-0.0)./(theta_c)).*arc_angleS(ind==1) & d(ind==1)<=(r(2)); %& arc_angleS(ind==1)<=theta_c ;
% save the information in continent 
continent(angle_c==1)=1.0;
Layout= d;
d = []; 
Layout(d<r(1) | d>r(2)) = NaN;
Layout(arc_angleS>obj.theta | arc_angleS<0)=NaN;
Layout = Layout-obj.R(2);
% Compute the length of the curved slab as a function of the mid distance
% layer. 
Length(~isnan(Layout))= r_m.*arc_angleS(slab==1 & angle<=theta)*pi/180; % compute the length associated with the 


if strcmp(Weak_Slab,'Weak')
    r(1) = r(2);
    r(2) = r(2)+obj.tk_WZ;
    if obj.theta == 90
        sl = 0;
    end
    %=============

end


p1(1)    = C(1)+r(1)*sin(ang_);
p1(2)    = C(2)+r(1)*cos(ang_);
p2(1) = C(1)+r(2)*sin(ang_);
p2(2) = C(2)+r(2)*cos(ang_);
p3(1)    = p1(1)+L0*sin(ang_2);
p3(2)    = p1(2)+L0*cos(ang_2);
p4(1)    = p2(1)+L0*sin(ang_2);
p4(2)     = p2(2)+L0*cos(ang_2);
%
Py(1) = p1(1);
Py(2) = p2(1);
Py(3) = p4(1);
Py(4) = p3(1);
Pz(1) = p1(2);
Pz(2) = p2(2);
Pz(3) = p4(2);
Pz(4) = p3(2);
% Inpolygon
[in,~] = inpolygon(x,z,Py,Pz);
P = [x(in), z(in)];
Layout(in) = -(find_distance_linear(P,p2,p4))';
B_time = cputime;
disp(['Time Loop = ', num2str(B_time-A_time)]);
obj.Length = compute_length_slab();
obj.Layout = reshape(Layout,size(A.Xpart));
obj.continent = reshape(continent,size(A.Xpart));
end


function [d] = find_distance_linear(P,p1,p2)

% Ok, wiki saves my day because I was too lazy:
A  = abs((p2(1)-p1(1)).*(p1(2)-P(:,2))-(p1(1)-P(:,1)).*(p2(2)-p1(2)));
B  = (p2(1)-p1(1)).^2+(p2(2)-p1(2)).^2;
d  = A./sqrt(B);

end
